---
title: Regulatory Networks of Lineage Differentiation 
author: "Thanneer Perumal"
date: '`r date()`'
output: pdf_document
---
```{r knit2synapse, eval = FALSE, include=FALSE}
library(synapseClient)
library(knitr)
library(knit2synapse)

synapseLogin()

knit2synapse::knitToFolderEntity(file = 'Section3_RegulationOfLineageDifferentiation.Rmd',
                                 parentId = "syn7162983",
                                 entityName = "3 Regulatory Networks of Lineage Differentiation")
```

```{r libs, echo=FALSE, warning=FALSE, message=FALSE, include=FALSE}
## It is assumed your working directory is where this file is

# Clear R console screen output
cat("\014")

# Load libraries
library(CovariateAnalysis)
library(data.table)
library(tidyr)
library(plyr)
library(dplyr)
library(stringr)

library(ggplot2)
library(RColorBrewer)
library(ComplexHeatmap)
library(matrixStats)
library(igraph)

library(synapseClient)
library(knitr)
library(githubr)

synapseLogin()

library(parallel)
library(doParallel)
library(foreach)

cl = makeCluster(6)
registerDoParallel(cl)

options(xtable.type="html")

knitr::opts_chunk$set(
  echo=FALSE,
  warning=FALSE,
  message=FALSE,
  error = FALSE,
  tidy = FALSE,
  cache = TRUE)
```

```{r synapseStore.params, include=FALSE}
parentId = "syn7162983"
ALL_USED_IDs = c()

thisFileName = 'Section3_RegulationOfLineageDifferentiation.Rmd'

# Github link
thisRepo <- getRepo(repository = "th1vairam/pcbc_c4_analysis", 
                    ref="branch", 
                    refName='publication')

thisFile <- getPermlink(repository = thisRepo,
                        repositoryPath=paste0('code/Rmd/', thisFileName))

# Populate wiki with results
CODE <- Folder(name = '3 Regulatory Networks of Lineage Differentiation', parentId = 'syn7162983')
CODE <- synStore(CODE)
```

### Data download from synapse
#### Get raw logCPM counts from synapse
```{r getRawCount, include=FALSE}
expr.id = c(mrna = 'syn5011095', mirna = 'syn5014454', methyl = 'syn4487642')
ALL_USED_IDs = c(ALL_USED_IDs, as.character(expr.id))
expr = lapply(expr.id, downloadFile)
```

#### Get covariates from synapse
```{r covars, include=FALSE}
covariates.id = c(mrna = 'syn5011149', mirna = 'syn5014460', methyl = 'syn4487669')
covariates.table.id = c(mrna = 'syn3156503', mirna = 'syn3219876', methyl = 'syn3156828')
ALL_USED_IDs = c(ALL_USED_IDs, as.character(covariates.id), as.character(covariates.table.id))
covariates = lapply(covariates.id, downloadFile)
covariates.table = lapply(covariates.table.id, function(x){
  synTableQuery(paste('select UID,C4_Cell_Line_ID from',x))@values
})

covariates = mapply(function(x,y){
  left_join(x,y)
},covariates, covariates.table)
```

#### Get all possible TFs from synapse
```{r TFs}
TFs = downloadFile('syn6040938')$feature
ALL_USED_IDs = c(ALL_USED_IDs, 'syn6040938')
```

#### Get pluripotency and germline specific signatures from synapse
```{r get.markers}
state.specific.signatures = downloadFile('syn7187534')
ALL_USED_IDs = c(ALL_USED_IDs, 'syn7187534')
```

#### Get differential expression results from synapse
```{r thresholds, echo=TRUE}
pval.th <- 0.01

mrna.lfc.th <- log2(2)
mirna.lfc.th <- log2(2)
methyl.changeBeta.th <- 0.35
splicing.changePSI.th <- 0.2
```

```{r diffexp, include=FALSE}
### Download differential expression results from synapse
diffexp.id = c(mrna = 'syn5013690', mirna = 'syn5014584', methyl = 'syn4527629', splicing = 'syn5049321')
ALL_USED_IDs = c(ALL_USED_IDs, as.character(diffexp.id))

# Diff states in a sensible, quasi time-based ordering
orderedDiffState = sort(c("SC", "MESO5", "DE", "MESO15", "MESO30", "ECTO", "EB"))
Comparisons = apply(combn(sort(orderedDiffState), 2), 2, function(x){paste(x, collapse = '_vs_')})

# Get mrna differential expression results from synapse
diffexp = list()
diffexp$mrna = downloadFile(diffexp.id['mrna']) %>%
  dplyr::rename(feature = GeneSymbol) %>%
  tidyr::separate(Comparison, into = c('V1','Comparison','V3'), sep = '\\__') %>%
  dplyr::filter(adj.P.value <= pval.th & abs(logFC) >= mrna.lfc.th & Comparison %in% Comparisons) %>%
  dplyr::select(feature, Comparison, adj.P.value, logFC) 

# Get mirna differential expression results from synapse
diffexp$mirna = downloadFile(diffexp.id['mirna']) %>%
  dplyr::rename(feature = GeneSymbol) %>%
  tidyr::separate(Comparison, into = c('V1','Comparison','V3'), sep = '\\__') %>%
  dplyr::filter(adj.P.value <= pval.th & abs(logFC) >= mirna.lfc.th & Comparison %in% Comparisons) %>%
  dplyr::select(feature, Comparison, adj.P.value, logFC) 

# Get methyl differential expression results from synapse
diffexp$methyl = downloadFile(diffexp.id['methyl']) %>%
  dplyr::select(-one_of('feature')) %>%
  dplyr::rename(feature = methProbeIDs) %>%
  tidyr::separate(Comparison, into = c('V1','Comparison','V3'), sep = '\\__') %>%
  dplyr::filter(adj.P.value <= pval.th & abs(changeBETA) >= methyl.changeBeta.th & Comparison %in% Comparisons) %>%
  dplyr::select(feature, Comparison, adj.P.value, logFC, changeBETA) 

# Get splicing differential expression results from synapse
diffexp$splicing = downloadFile(diffexp.id['splicing']) %>%
  dplyr::select(-one_of('feature')) %>%
  plyr::rename(c('Minor-Isoform' = 'feature')) %>%
  tidyr::separate(Comparison, into = c('V1','Comparison','V3'), sep = '\\__') %>%
  dplyr::filter(adj.P.value <= pval.th & abs(changePSI) >= splicing.changePSI.th & Comparison %in% Comparisons) %>%
  dplyr::select(feature, Comparison, adj.P.value, logFC, changePSI) 

diffexp = rbindlist(diffexp, use.names = T, fill = T, idcol = 'Assay') %>%
  tidyr::separate(Comparison, c('from.state','to.state'), sep = '_vs_')

diffexp = rbindlist(list(diffexp,
                         diffexp %>%
                           dplyr::rename(to.state = from.state, from.state = to.state) %>%
                           dplyr::mutate(
                             logFC = -logFC, changeBETA = -changeBETA, changePSI = -changePSI)),
                    use.names = T, fill =T) %>%
  dplyr::mutate(Direction = logFC/abs(logFC)) %>%
  dplyr::select(-changePSI)
```
Based on the previous analysis here we define four groups of differentiation stages: SC, DE, ECTO and MESO (which is a intersection of mesoderm at day 15 and 30).

#### Get co-expression results from synapse
```{r coexp, include = FALSE}
coexp.id = 'syn5662375'
ALL_USED_IDs = c(ALL_USED_IDs, coexp = coexp.id)
coexpression = downloadFile(coexp.id) %>%
  dplyr::select(feature, target, feature.assay, target.assay, dataSource,contains('SC')) %>%
  filter(feature.assay != 'splicing', target.assay != 'splicing') %>%
  tidyr::gather(comparison, coexpression, -feature, -target, 
                -feature.assay, -target.assay, -dataSource) %>%
  tidyr::separate(comparison, c('from.state', 'to.state'), sep = '_vs_') %>%
  dplyr::mutate(Assay = paste(feature.assay,target.assay, sep = '_')) %>%
  ddply(.(feature.assay), .fun = function(x){
    if(any(unique(x$feature.assay) %in% c('methyl','mirna')))
      return(filter(x, coexpression <= 0))
    else
      return(x)
  })

writeLines('Total number of possible interactions between assays are')
coexpression %>%
  dplyr::select(feature, target, feature.assay, target.assay) %>%
  unique %>%
  group_by(feature.assay, target.assay) %>%
  summarise(count = n()) %>%
  spread(target.assay, count) %>%
  kable

p = ggplot(coexpression, aes(x = Assay, y = coexpression)) + geom_violin()
p = p + theme(axis.text.x = element_text(angle = 45, hjust = 1))
p

writeLines('Out of all possible interactions filter the top 10% of interactions from both the tails of distribution as active interactions')
coexpression = coexpression %>%
  ddply(.(Assay), .fun = function(x){
    cut_off = quantile(abs(x$coexpression), 0.9, na.rm = T)
    filter(x, abs(coexpression) >= cut_off)
  })
total.interactions = coexpression %>%
  dplyr::select(feature, target, feature.assay, target.assay) %>%
  unique %>%
  group_by(feature.assay, target.assay) %>%
  summarise(count = n()) 

total.interactions %>%
  spread(target.assay, count) %>%
  kable

# Flip states and append interaction list
coexpression = rbindlist(list(coexpression,
                              coexpression %>% 
                                dplyr::rename(from.state = to.state, to.state = from.state)),
                         use.names = T, fill = T) %>%
  filter(from.state == 'SC')
```

### Regulatory networks of lineage differentiation
```{r reg.net}
all.int = coexpression %>%
  inner_join(diffexp %>%
               dplyr::rename(target = feature, target.assay = Assay, target.lfc = logFC, target.fdr = adj.P.value,
                             target.beta = changeBETA, target.direction = Direction) %>%
               filter(from.state == 'SC', target.assay != 'splicing')) %>%
  inner_join( diffexp %>%
                dplyr::rename(feature.assay = Assay, feature.lfc = logFC, feature.fdr = adj.P.value, 
                              feature.beta = changeBETA, feature.direction = Direction) %>%
                filter(from.state == 'SC', feature.assay != 'splicing')) 

# Add features that are differentially expressed but doesn't have any coexpression interactions (singletons)
singleton.int = diffexp %>% 
  filter(from.state == 'SC', Assay != 'splicing') %>%
  ddply(.(from.state, to.state), .fun = function(x, allInt){
    tmp = filter(allInt, from.state == unique(x$from.state), to.state == unique(x$to.state))
    filter(x, !(feature %in% tmp$target)) %>%
      dplyr::rename(target.assay = Assay, target = feature, target.fdr = adj.P.value,
                    target.lfc = logFC, target.beta = changeBETA, target.direction = Direction)
  }, all.int)

all.int = rbindlist(list(all.int, singleton.int), 
                    use.names = T, fill = T)

all.int$feature[is.na(all.int$feature)] = 'NONE'
all.int$feature.assay[all.int$feature %in% TFs] = 'TF'
all.int$target.assay[all.int$target %in% TFs] = 'TF'
all.int$Assay = paste(all.int$feature.assay, all.int$target.assay, sep = '_')
all.int = filter(all.int, ! (Assay %in% c('mrna_mrna', 'mrna_TF')))

# Combine MESO15 and 30 together
all.int.MESO  = filter(all.int, to.state %in% c('MESO15','MESO30'))
all.int.notMESO  = filter(all.int, to.state %in% c('DE','ECTO','EB','MESO5'))

all.int.MESO = all.int.MESO %>%
  ddply(.(feature, target), .fun = function(x){
    if(dim(x)[1] == 2)
        x = top_n(x,1,abs(target.lfc))
    else
      return(NULL)
  })
all.int.MESO$to.state = 'MESO'
all.int = rbindlist(list(all.int.notMESO, all.int.MESO), fill = T, use.names = T)

# Store active interactions to synapse
all.int %>% write.table(file = 'ActiveInteractions.tsv', sep = '\t', quote=F, row.names = F)
obj = File('ActiveInteractions.tsv', 
           name = 'Active Interactions',
           parentId = CODE$properties$id)
obj = synStore(obj, 
               activityName = 'Network Identification', 
               executed = thisFile, 
               used = as.character(ALL_USED_IDs))
```

### Network analysis
Functions for regulator analysis
```{r fxn}
# Function to perform Fishers enrichment analysis
fisherEnrichment <- function(genes.in.significant.set, # A character vector of differentially expressed or some significant genes to test
                             genes.in.gene.set, # A character vector of genes in gene set like GO annotations, pathways etc...
                             genes.in.background # Background genes 
){
  genes.in.significant.set = intersect(genes.in.significant.set, genes.in.background) # back ground filtering
  genes.in.nonsignificant.set = base::setdiff(genes.in.background, genes.in.significant.set)
  genes.in.gene.set = intersect(genes.in.gene.set, genes.in.background) # back ground filtering
  genes.our.gene.set = base::setdiff(genes.in.background,genes.in.gene.set)
  
  tp = length(intersect(genes.in.gene.set, genes.in.significant.set))             
  fp = length(intersect(genes.in.gene.set, genes.in.nonsignificant.set))
  fn = length(intersect(genes.our.gene.set, genes.in.significant.set))
  tn = length(intersect(genes.our.gene.set, genes.in.nonsignificant.set))
  
  pval = fisher.test(matrix(c(tp, fp, fn, tn),nrow=2, ncol=2), alternative="greater")
  odds = (tp*tn)/(fp*fn)
  
  return(data.frame(pval = pval$p.value,
                    ngenes = length(genes.in.gene.set),
                    noverlap = tp,
                    odds = odds,
                    Genes = paste(intersect(genes.in.gene.set, genes.in.significant.set), collapse = '|')
  )
  )
}

# Function to perform un-weighted key regulator analysis for directed networks
regulatorAnalysis.directed <- function(g, G, h=3, FDR = 0.05){
  
  # Convert adjacency to igraph object
  background.genes = igraph::V(g)$name
  
  # Find H-Layer neighborhood
  neighbor.nodes = lapply(1:h, function(hi,sg){
    igraph::ego(sg, order = hi, nodes = igraph::V(sg), mode = 'out')
  }, g)
  
  # Perform enrichment analysis for every gene in every layer and pick the minimum p-value
  fdr = sapply(1:length(neighbor.nodes), function(x, neighborNodes, G, backgroundGenes){
    foreach::foreach(i = 1:length(neighborNodes[[x]]), 
                     .combine = c, 
                     .export =c('neighborNodes', 'G', 'backgroundGenes', 'fisherEnrichment')) %dopar% {
      fisherEnrichment(names(neighborNodes[[x]][i][[1]]), G, backgroundGenes)$pval
    }
  }, neighbor.nodes, G, background.genes) %>%
    apply(1, min, na.rm = T) %>%
    stats::p.adjust(method = 'fdr')
  names(fdr) = background.genes
  
  # Calculate node degree for identifying global regulators
  node.degree = igraph::degree(g)
  mean.node.degree = mean(node.degree, na.rm = T)
  stddev.node.degree = sd(node.degree, na.rm = T)
  
  # Find leaf nodes to identify global regulators
  node.in.degree = igraph::degree(g, mode = 'in')
  
  key.regulators = list()
  key.regulators$fdr = fdr
  key.regulators$regulators = background.genes[(fdr <= FDR)]
  key.regulators$global.regulators = background.genes[((node.degree > (mean.node.degree + 2*stddev.node.degree)) | (node.in.degree == 0)) & (fdr <= FDR)]
  key.regulators$local.regulators = setdiff(key.regulators$regulators, key.regulators$global.regulators)
  
  return(key.regulators)
}

# Function to calculate node scores
score.nodes <- function(g, G, h = 3, mode = 'out'){
  
  # Get background genes from graph
  background.genes = igraph::V(g)$name
  G = G[intersect(background.genes, names(G))]
  G.not = rep(0, length(setdiff(background.genes, names(G))))
  names(G.not) = setdiff(background.genes, names(G))
  G = c(G, G.not)
  
  # Calculate node degree for identifying global regulators
  node.degree = igraph::degree(g)
  mean.node.degree = mean(node.degree, na.rm = T)
  stddev.node.degree = sd(node.degree, na.rm = T)
  
  # Find H-Layer neighborhood
  neighbor.nodes = lapply(1:h, function(hi,sg){
    igraph::ego(sg, order = hi, nodes = igraph::V(sg), mode = mode, mindist = hi)
  }, g)
  
  # Find summed weight of current node based on h-layer neighbors
  node.scores = foreach::foreach (x = 1:length(neighbor.nodes), .combine = cbind) %dopar% {
    score = sapply(neighbor.nodes[[x]], function(y, G){
      sum(G[names(y)] * (1/node.degree[names(y)]))
    }, G)
  } 
  node.scores = rowSums(node.scores * t(matrix(rep(1/c(1:h), length(G)), h, length(G))), na.rm = T)
  node.scores = node.scores + G
  names(node.scores) = background.genes
  
  return(node.scores)
}

# Function to find weighted regulators on directed networks
regulatorAnalysis.directed_weighted <- function(g, G, h = 3, n = 100, FDR = 0.05){
  
  # Convert adjacency to igraph object
  background.genes = igraph::V(g)$name
  
  # Compute node scores based on neighborhood scores
  node.scores = score.nodes(g, G, h, mode = 'out')
  
  # Permute node labels and calculate null scores
  perm.node.scores = foreach::foreach(i = 1:n, 
                                      .combine = cbind, 
                                      .packages = c('igraph', 'dplyr', 'parallel', 'doParallel', 'foreach'),
                                      .export = c('score.nodes'),
                                      .verbose = TRUE) %dopar% {
    pg = igraph::permute(g, sample(1:length(background.genes), length(background.genes)))
    perm.node.scores = score.nodes(pg, G, h, mode = 'out')
  } 
  
  # Perform one sample t-test to estimate significance
  pval = foreach::foreach(i = 1:length(background.genes), .combine = rbind) %dopar% {
    tmp = t.test(perm.node.scores[i,], mu = node.scores[i], alternative = 'less')
    data.frame(pval = tmp$p.value, t = tmp$statistic, t.low = tmp$conf.int[1], t.high = tmp$conf.int[2])
  }
  fdr = p.adjust(pval$pval, method = 'fdr')
  names(fdr) = background.genes
  
  # Calculate node degree for identifying global regulators
  node.degree = igraph::degree(g)
  mean.node.degree = mean(node.degree, na.rm = T)
  stddev.node.degree = sd(node.degree, na.rm = T)
  
  # Find leaf nodes to identify global regulators
  node.in.degree = igraph::degree(g, mode = 'in')
  
  # Promote high degree nodes as global regulators 
  key.regulators = list()
  key.regulators$scores = node.scores
  key.regulators$fdr = fdr
  key.regulators$regulators = background.genes[(fdr <= FDR)]
  key.regulators$global.regulators = background.genes[((node.degree > (mean.node.degree + 2*stddev.node.degree)) | (node.in.degree == 0)) & (fdr <= FDR)]
  key.regulators$local.regulators = setdiff(key.regulators$regulators, key.regulators$global.regulators)
  
  return(key.regulators)
}
```

```{r score.nodes}
# Create state transition networks from edgelist
all.graphs = all.int %>%
  dlply(.(to.state), .fun = function(x){
  g <- x %>%
    dplyr::select(feature, target) %>%
    filter(feature != 'NONE', feature != target) %>%
    as.data.frame() %>%
    igraph::graph_from_data_frame()
})

# Extract signatures
signatures = dlply(state.specific.signatures, .(from.state), .fun = function(x){unique(x$feature)})
signatures$DE = unique(c(signatures$DE, signatures$SC))
signatures$ECTO = unique(c(signatures$ECTO, signatures$SC))
signatures$MESO = unique(c(signatures$MESO, signatures$SC))
signatures$SC = NULL

# Perform key regulator analysis (unweighted)
key.regulators.unw = mapply(function(g, G){
  regulatorAnalysis.directed(g, G, h=4, FDR = 0.05)
}, all.graphs[c('DE','ECTO','MESO')], signatures[c('DE','ECTO','MESO')], SIMPLIFY = F)
names(key.regulators.unw) = c('DE','ECTO','MESO')

# Store results to synapse
save(list = 'key.regulators.unw', file = 'kye.regulators.unw.RData')
obj = File('kye.regulators.unw.RData', name = 'Key Regulators UnWeighted', parentId = CODE$properties$id)
obj = synStore(obj, activityName = 'Scoring network nodes', 
               executed = thisFile, 
               used = as.character(ALL_USED_IDs))
```

Weighted scoring of network nodes (based on pvalue)
```{r score.nodes2, cache=TRUE}
# Extract signatures
weighted.signatures = lapply(names(signatures), function(x, Signatures, DiffExp){
  dplyr::filter(DiffExp, from.state == 'SC', to.state == x, feature %in% Signatures[[x]]) %>%
    dplyr::select(feature, Assay, adj.P.value, logFC) %>%
    ddply(.(Assay), .fun = function(y){
      y = dplyr::mutate(y,
                        pval = -log10(y$adj.P.value),
                        rlfc = rank(-abs(y$logFC), ties.method = 'average'),
                        rlfc = -log10(rlfc/max(rlfc)), 
                        score = pval*rlfc)
    }) %>%
    daply(.(feature), .fun = function(y){
      y$score
    })
}, signatures, diffexp)
names(weighted.signatures) = names(signatures)

weighted.signatures$MESO = dplyr::filter(diffexp, 
                                         from.state == 'SC', 
                                         to.state %in% c('MESO15', 'MESO30'), 
                                         feature %in% signatures[['MESO']]) %>%
  dplyr::select(feature, Assay, to.state, adj.P.value, logFC) %>%
  ddply(.(Assay, to.state), .fun = function(y){
      y = dplyr::mutate(y,
                        pval = -log10(y$adj.P.value),
                        rlfc = rank(-abs(y$logFC), ties.method = 'average'),
                        rlfc = -log10(rlfc/max(rlfc)), 
                        score = pval*rlfc)
    }) %>%
  daply(.(feature), .fun = function(y){max(y$score, na.rm=T)})

# Perform key regulator analysis (weighted)
key.regulators.w = mapply(function(g, G){
  regulatorAnalysis.directed_weighted(g, G, h = 4, n = 100, FDR = 0.05)
}, all.graphs[c('DE','ECTO','MESO')], weighted.signatures[c('DE','ECTO','MESO')], SIMPLIFY = F)
names(key.regulators.w) = c('DE','ECTO','MESO')

# Store results to synapse
save(list = 'key.regulators.w', file = 'key.regulators.w.RData')
obj = File('key.regulators.w.RData', name = 'Key Regulators Weighted', parentId = CODE$properties$id)
obj = synStore(obj, activityName = 'Scoring network nodes', 
               executed = thisFile, 
               used = as.character(ALL_USED_IDs))

stopCluster(cl)
```