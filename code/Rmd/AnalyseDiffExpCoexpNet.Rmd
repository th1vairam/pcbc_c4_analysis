---
title: "Integrated omic networks of differentiation"
author: "Thanneer Perumal"
date: '`r date()`'
output: html_document
---
```{r knit2synapse, eval = FALSE, include=FALSE}
library(synapseClient)
library(knitr)
library(githubr)

synapseLogin()

knit2synapse::knitToFolderEntity(file = 'AnalyseDiffExpCoexpNet.Rmd',
                                 parentId = "syn5194922",
                                 entityName = 'Integrated omic networks of differentiation')
```

```{r libs, echo=FALSE, warning=FALSE, message=FALSE, include=FALSE}
## It is assumed your working directory is where this file is

# Clear R console screen output
cat("\014")

# Load libraries
library(CovariateAnalysis)
library(data.table)
library(tidyr)
library(plyr)
library(dplyr)
library(stringr)

library(matrixStats)
library(biomaRt)
library(xlsx)

library(igraph)
library(ggplot2)

options(xtable.type="html")

knitr::opts_chunk$set(
  echo=FALSE,
  warning=FALSE,
  message=FALSE,
  error = FALSE,
  tidy = FALSE,
  cache = TRUE)
```

```{r synapseStore.params, cache=FALSE}
parentId = "syn5194922"
ALL_USED_IDs = c()

# Create folder to store results in synapse
ActivityName <- 'Analyse differential expression in conjuction with coexpression between assays'

ThisFileName <- 'AnalyseDiffExpCoexpNet.Rmd'

# Github link
ThisRepo <- getRepo(repository = "th1vairam/pcbc_c4_analysis", 
                    ref="branch", 
                    refName='discordant_anal')

ThisFile <- getPermlink(repository = ThisRepo,
                        repositoryPath=paste0('code/Rmd/', ThisFileName))    

# Populate wiki with results
CODE <- Folder(name = 'Integrated omic networks of differentiation', parentId = parentId)
CODE <- synStore(CODE)
```

#### Get TFs list from synapse
```{r getTFs}
ALL_USED_IDs = c(ALL_USED_IDs, TFs = 'syn6040938')
TFs = downloadFile('syn6040938')
```

#### Get median expression from synapse
```{r getMedianExpr}
counts.id = 'syn5637772'
ALL_USED_IDs = c(ALL_USED_IDs, counts = counts.id)
counts = downloadFile(counts.id)
counts$Assay[counts$feature %in% TFs$feature] = 'TF'
gc()
```

#### Get differential expression from synapse
```{r download.diff.exp}
### Download differential expression results from synapse
diffexp.ids = c(mrna = 'syn5013690', mirna = 'syn5014584', 
                methyl = 'syn4527629', splicing = 'syn5049321')
ALL_USED_IDs = c(ALL_USED_IDs, diffexp.ids)

orderedDiffState = c("DE", "EB", "ECTO", "MESO15", "MESO30", "MESO5", "SC")
Comparisons = apply(combn(orderedDiffState, 2), 2, function(x){paste(x, collapse = '_vs_')})

diffexp = lapply(diffexp.ids, function(id){
  x = downloadFile(id) %>%
    dplyr::select(-one_of('feature'))
  colnames(x)[1] = 'feature'
  x = x %>%
    dplyr::filter(adj.P.value <= 0.05) %>%
    tidyr::separate(Comparison, into = c('V1','Comparison','V3'), sep = '\\__') %>%
    dplyr::select(feature, Comparison, adj.P.value, logFC, matches('changeBETA'), matches('changePSI'))
}) %>% 
  rbindlist(idcol = 'Assay', use.names = T, fill = T) 
diffexp$Assay[diffexp$feature %in% TFs$feature] = 'TF'

# Filter differential expression
diffexp = diffexp %>%
  filter((Assay == "mrna" & abs(logFC) >= log2(2)) |
           (Assay == "TF" & abs(logFC) >= log2(2)) |
           (Assay == "mirna" & abs(logFC) >= log2(2)) |
           (Assay == "methyl" & abs(changeBETA) >= 0.35) |
           (Assay == "splicing" & abs(changePSI) >= 0.2),
         Comparison %in% Comparisons)

# Write all active differential expression to synapse
write.table(diffexp, file = paste('allSignificantDiffExp','tsv',sep = '.'), sep = '\t', row.names=F, quote=F)
allDE.obj = File(paste('allSignificantDiffExp','tsv',sep = '.'), 
                 name = 'All Significant Differential Expression', 
                 parentId = CODE$properties$id)
allDE.obj = synStore(allDE.obj, used = as.character(ALL_USED_IDs), executed = ThisFile, activityName = ActivityName)

writeLines('Unique entities differntially expressed')
diffexp %>% 
  group_by(Assay, Comparison) %>% 
  summarise(count = length(unique(feature))) %>% 
  spread(Assay, count) %>%
  kable
```

#### Get coexpression from synapse
```{r getCoexp}
coexp.id = 'syn5662375'
ALL_USED_IDs = c(ALL_USED_IDs, coexp = coexp.id)
coexpression = downloadFile(coexp.id) %>%
  filter(feature %in% diffexp$feature, target %in% diffexp$feature,
         feature.assay != 'splicing', target.assay != 'splicing',
         abs(coexpression != 1)) %>%
  gather(Comparison, coexpression, -feature, -target, -feature.assay, -target.assay, -dataSource, -Assay) 

# Plot the distribution of coexpression values
writeLines('Distribution of absolute coexpression for differentially expressed entities')
p = ggplot(coexpression, aes(y = abs(coexpression), x = Assay)) + geom_boxplot()
p

# Get top 20% of coexpressed interactions for every interaction assay type (except splicing related interactions)
coexpression = split(coexpression, coexpression$Assay)
coexpression = lapply(coexpression, function(foo){
  if (unique(foo$Assay) == 'splicing_mrna')
    return(foo)
  
  if (unique(foo$Assay) == 'mirna_mrna')
    foo = filter(foo, coexpression <= 0)
  
  cut.off = quantile(abs(foo$coexpression), na.rm = T, probs = 0.8)
  foo = filter(foo, abs(coexpression) >= cut.off)
  return(foo)
}) %>%
  rbindlist

# Split TFs from non-TFs
ind = which(coexpression$feature %in% TFs$feature)
coexpression$feature.assay[ind] = 'TF'

ind = which(coexpression$target %in% TFs$feature)
coexpression$target.assay[ind] = 'TF'

coexpression$Assay = paste(coexpression$feature.assay, coexpression$target.assay, sep = '_')

# Filter any mrna-mrna related interactions
coexpression = coexpression %>%
  filter(Assay != "mrna_mrna")
gc()
```

#### Get enrichment results from synapse
```{r enrich}
enrich.id = 'syn5979265'
ALL_USED_IDs = c(ALL_USED_IDs, enrich = enrich.id)
enrich.obj = synGet(enrich.id)

# Get all genes that are mapped to a enriched pathway (top 100)
getGenes <- function(x){
  x1 = x %>%
    apply(1, function(y){
      str_split(y[-(1:3)], '\\|') %>% unlist %>% unique %>% na.omit %>% as.character
    })
  names(x1) = paste0(x$GeneSetName, '(', x$CategoryName, ')')
  x1 = x1 %>% 
    lapply(rownameToFirstColumn, 'x') %>% 
    rbindlist(idcol = 'feature') %>% 
    dplyr::rename(target = DF) %>%
    dplyr::select(-x)
}

tmp.mrna = read.xlsx(enrich.obj@filePath, sheetName = "mRNA-Genes-FDR0.01-Top100") %>%
  getGenes %>%
  dplyr::mutate(feature.assay = 'pathways',
                target.assay = 'mrna')

tmp.mirna = read.xlsx(enrich.obj@filePath, sheetName = "miRNA-miRNA-FDR0.01-Top100") %>%
  getGenes %>%
  dplyr::mutate(feature.assay = 'pathways',
                target.assay = 'mirna')

tmp.methyl = read.xlsx(enrich.obj@filePath, sheetName = "methyl-methyl-FDR0.01-Top100") %>%
  getGenes %>%
  dplyr::mutate(feature.assay = 'pathways',
                target.assay = 'methyl')

# tmp.splicing = read.xlsx(enrich.obj@filePath, sheetName = "splicing-splicing-FDR0.01-Top100") %>%
#   getGenes %>%
#   dplyr::select(-x)

pathways = rbindlist(list(tmp.mrna, tmp.mirna, tmp.methyl), use.names=T, fill = T) %>%
  filter(target %in% diffexp$feature)

ind = which(pathways$target %in% TFs$feature)
pathways$target.assay[ind] = 'TF'
gc()
```

#### Get cluster mapping from differential expression results
```{r diffExpClusters}
diffexp.cluster.mrna.id = 'syn5231514'
ALL_USED_IDs = c(ALL_USED_IDs, mrna = diffexp.cluster.mrna.id)
diffexp.cluster.mrna = downloadFile(diffexp.cluster.mrna.id)

# Get identity mapping for individual clusters
mrna.ident = c("1" = "Not ECTO and MESO15", "4" = "DE and MESO5", "7" = "Late including ECTO", 
               "8" = "ECTO", "17" = "MESO30 and EB", "19" = "Everything", "20" = "Early including ECTO", 
               "21" = "SC and Early", "24" = "Not SC", "30" = "Not DE and MESO5", "31" = "SC and MESO15",
               "37" = "SC, ECTO and MESO15", "47" = 'DE and all MESO', "57" = "MESO5", "70" = "Not SC and ECTO",
               "76" = "Late", "78" = "EB", "79" = "Late wo MESO15", "81" = "SC and Late","83" = "Not MESO15","94" = "MESO15",
               "119" = "Not ECTO","130" = "Early with MESO15","133" = "SC, ECTO, MESO30 and EB", "136" = "SC, DE and MESO5")
mrna.ident = rownameToFirstColumn(mrna.ident, "cluster")

# Subset TFs only from mrnas (for Bruce A)
diffexp.cluster.TF = diffexp.cluster.mrna %>%
  ddply(.(cluster, cluster.name), function(x, TF){
    x$feature = x$feature %>%
      str_split('\\,') %>%
      unlist %>%
      intersect(TFs$feature) %>%
      paste(collapse = ',')
    return(x)
  }, TFs)

diffexp.cluster.mrna = dplyr::mutate(diffexp.cluster.mrna, cluster = as.character(cluster)) %>%
  left_join(mrna.ident) %>%
  dplyr::rename(cluster.name = DF)

mrna.cluster = lapply(diffexp.cluster.mrna$feature, function(x){
  str_split(x, ',')[[1]] %>% unique
})
names(mrna.cluster) = diffexp.cluster.mrna$cluster.name
mrna.cluster = mrna.cluster %>% 
  lapply(rownameToFirstColumn, 'x') %>% 
  rbindlist(idcol = 'cluster') %>% 
  dplyr::rename(feature = DF ) %>%
  dplyr::select(-x)
  
######################################################
# Get differential expression clusters from miRNA (ALL)
diffexp.cluster.mirna.id = 'syn5203316'
ALL_USED_IDs = c(ALL_USED_IDs, mirna.cluster = diffexp.cluster.mirna.id)
diffexp.cluster.mirna = downloadFile(diffexp.cluster.mirna.id)

# Get identity mapping for individual clusters
mirna.ident = c("1" = "SC", "2" = "EB", "3" = "Late", "4" = "ECTO", 
               "6" = "All", "7" = "MESO5", "8" = "MESO15", "10" = "SC and ECTO", 
               "11" = "DE and MESO5", "12" = "Early", "15" = "SC and DE")
mirna.ident = rownameToFirstColumn(mirna.ident, "cluster")

diffexp.cluster.mirna = dplyr::mutate(diffexp.cluster.mirna, cluster = as.character(cluster)) %>%
  left_join(mirna.ident) %>%
  dplyr::rename(cluster.name = DF)

mirna.cluster = lapply(diffexp.cluster.mirna$feature, function(x){
  str_split(x, ',')[[1]] %>% unique
})
names(mirna.cluster) = diffexp.cluster.mirna$cluster.name
mirna.cluster = mirna.cluster %>% 
  lapply(rownameToFirstColumn, 'x') %>% 
  rbindlist(idcol = 'cluster') %>% 
  dplyr::rename(feature = DF ) %>%
  dplyr::select(-x)

######################################################
# Get differential expression clusters from DNA methylation probes (ALL)
diffexp.cluster.methyl.id = 'syn5229656'
ALL_USED_IDs = c(ALL_USED_IDs, methyl.cluster = diffexp.cluster.methyl.id)
diffexp.cluster.methyl = downloadFile(diffexp.cluster.methyl.id)

# Get identity mapping for individual clusters
methyl.ident = c('2' = 'Not ECTO', '5' = 'Not SC', 
                 '7' = 'Not SC and ECTO', '9' = 'EB', 
                 '12' = 'All', '13' = 'Early', 
                 '19' = 'ECTO and EB')
methyl.ident = rownameToFirstColumn(methyl.ident, "cluster")

diffexp.cluster.methyl = dplyr::mutate(diffexp.cluster.methyl, cluster = as.character(cluster)) %>%
  left_join(methyl.ident) %>%
  dplyr::rename(cluster.name = DF)

methyl.cluster = lapply(diffexp.cluster.methyl$feature, function(x){
  str_split(x, ',')[[1]] %>% unique
})
names(methyl.cluster) = diffexp.cluster.methyl$cluster.name
methyl.cluster = methyl.cluster %>% 
  lapply(rownameToFirstColumn, 'x') %>% 
  rbindlist(idcol = 'cluster') %>% 
  dplyr::rename(feature = DF ) %>%
  dplyr::select(-x)

counts = left_join(counts, 
          rbindlist(list(mrna.cluster, 
                         mirna.cluster, 
                         methyl.cluster), use.names = T))
gc()
```

#### Get active interactions
```{r actInt}
# Get all possible interactions
all.interactions = coexpression %>%
  dplyr::mutate(Assay = paste(feature.assay, target.assay, sep = '_')) %>%
  right_join(diffexp %>% 
               dplyr::rename(feature.assay = Assay, feature.fdr = adj.P.value,
                             feature.lfc = logFC, feature.chb = changeBETA, feature.cpsi = changePSI)) %>%
  left_join(diffexp %>%
              dplyr::rename(target = feature, target.assay = Assay, target.fdr = adj.P.value,
                            target.lfc = logFC, target.chb = changeBETA, target.cpsi = changePSI)) %>%
  tidyr::separate(Comparison, c('from.state','to.state'), sep = '_vs_') %>%
  dplyr::mutate(feature.direction = feature.lfc/abs(feature.lfc),
                target.direction = target.lfc/abs(target.lfc)) %>%
  filter(feature.assay != 'splicing')

# Write all active interactions to synapse
write.table(all.interactions, file = paste('allInteractions','tsv',sep = '.'), sep = '\t', row.names=F, quote=F)
allInt.obj = File(paste('allInteractions','tsv',sep = '.'), 
                  name = 'All Active Interactions', 
                  parentId = CODE$properties$id)
allInt.obj = synStore(allInt.obj, used = as.character(ALL_USED_IDs), executed = ThisFile, activityName = ActivityName)
```

#### Extract and store interaction results in synapse
```{r storeIntResult, results='asis', fig.height = 15, fig.width = 15}
# Creat a folder
fullNet.fold = Folder(name = 'Full Networks (without annotations)', parentId = CODE$properties$id)
fullNet.fold = synStore(fullNet.fold)

all.objs = lapply(orderedDiffState, function(diffstate, all.interactions, counts, fullNet.fold){
    edges = all.interactions %>%
      filter(from.state == diffstate | to.state == diffstate)
    
    edges.reverse = edges %>%
      dplyr::rename(from.state = to.state, to.state = from.state) %>%
      dplyr::mutate(feature.lfc = -feature.lfc, target.lfc = -target.lfc, 
                    feature.direction = -feature.direction, target.direction = -target.direction)
    
    edges = rbindlist(list(edges, edges.reverse), use.names=T, fill = T) %>%
      filter(feature.direction == 1, from.state == diffstate, to.state %in% setdiff(orderedDiffState, 'EB'))
    
    vertices = filter(counts, feature %in% unique(c(edges$feature, edges$target))) %>%
      data.frame
     
    # Write filtered interactions to synapse
    write.table(edges, file = paste(diffstate,'edges','tsv',sep = '.'), sep = '\t', row.names=F, quote=F)
    edge.obj = File(paste(diffstate,'edges','tsv',sep = '.'), name = paste(diffstate,'Edges'), parentId = fullNet.fold$properties$id)
    edge.obj = synStore(edge.obj, used = as.character(ALL_USED_IDs), executed = ThisFile, activityName = ActivityName)
    
    # Write filtered nodes to synapse
    write.table(vertices, file = paste(diffstate,'vertices','tsv',sep = '.'), sep = '\t', row.names=F, quote=F)
    vertices.obj = File(paste(diffstate,'vertices','tsv',sep = '.'), 
                        name = paste(diffstate,'Vertices'), 
                        parentId = fullNet.fold$properties$id)
    vertices.obj = synStore(vertices.obj, used = as.character(ALL_USED_IDs), executed = ThisFile, activityName = ActivityName)
    
    return(c(edge.obj, vertices.obj))
  }, all.interactions, counts, fullNet.fold)
```

Call ranking script seperately (see calculateVertexRanks.R, because of parallel implementation)

#### Get miRNA regulated TFs
```{r miRNATFS}
# Get stem cell specific mirnas and tfs
mirna.tf = all.interactions %>%
  filter(feature.assay == "mirna", target.assay == "TF", !is.na(target.lfc)) %>% 
  tidyr::separate(Comparison, c("to.state","from.state"), sep = '_vs_') %>%
  dplyr::select(-contains('chb'), -contains('cpsi'))

mirna.tf1 = mirna.tf %>%
  dplyr::mutate(feature.lfc = -feature.lfc,
                target.lfc = -target.lfc)
mirna.tf1$from.state = mirna.tf$to.state
mirna.tf1$to.state = mirna.tf$from.state

mirna.tf = rbindlist(list(mirna.tf, mirna.tf1),
                     use.names = T, fill = T) %>%
  dplyr::mutate(direction = feature.lfc/abs(feature.lfc)) %>%
  filter(direction == -1) %>%
  unique
  
imp.mirna.tf.edges = mirna.tf %>%
  filter((from.state == 'SC' & to.state %in% c('DE', 'ECTO', 'MESO5')) |
           (from.state == 'ECTO' & to.state %in% c('DE', 'MESO5')) |
           (from.state == 'MESO5' & to.state == 'DE')) %>%
  group_by(from.state, to.state) %>%
  top_n(25, feature.lfc)

imp.mirna.tf.counts = counts %>%
  filter(feature %in% c(imp.mirna.tf.edges$feature, imp.mirna.tf.edges$target))

# Write filtered interactions to synapse
write.table(imp.mirna.tf.edges, file = 'mirnaTFedges.tsv', sep = '\t', row.names=F, quote=F)
edge.obj = File('mirnaTFedges.tsv', name = 'miRNA TF Edges', parentId = CODE$properties$id)
edge.obj = synStore(edge.obj, used = as.character(ALL_USED_IDs), executed = ThisFile, activityName = ActivityName)
    
# Write filtered nodes to synapse
write.table(imp.mirna.tf.counts, file = 'mirnaTFvertices.tsv', sep = '\t', row.names=F, quote=F)
vertices.obj = File('mirnaTFvertices.tsv' , name = 'miRNA TF Vertices', parentId = CODE$properties$id)
vertices.obj = synStore(vertices.obj, used = as.character(ALL_USED_IDs), executed = ThisFile, activityName = ActivityName)
```

#### Store interaction results in synapse
```{r storeIntResult, results='asis', fig.height = 15, fig.width = 15}
# Creat a folder
fullNet.fold = Folder(name = 'Full Networks (without annotations)', parentId = CODE$properties$id)
fullNet.fold = synStore(fullNet.fold)

all.objs = all.interactions %>%
  dlply(.(Comparison), function(edge.prop, counts){
    
    vertex.prop = filter(counts,
                          feature %in% unique(c(edge.prop$feature, edge.prop$target))) %>%
       data.frame
     rownames(vertex.prop) = vertex.prop$feature
    
    # Write filtered interactions to synapse
    write.table(edge.prop, file = paste(unique(edge.prop$Comparison),'edges','tsv',sep = '.'), sep = '\t', row.names=F, quote=F)
    edge.obj = File(paste(unique(edge.prop$Comparison),'edges','tsv',sep = '.'), 
                    name = paste(unique(edge.prop$Comparison),'Edges'), 
                    parentId = fullNet.fold$properties$id)
    edge.obj = synStore(edge.obj, used = as.character(ALL_USED_IDs), executed = ThisFile, activityName = ActivityName)
    
    # Write filtered nodes to synapse
    write.table(vertex.prop, file = paste(unique(edge.prop$Comparison),'vertices','tsv',sep = '.'), sep = '\t', row.names=F, quote=F)
    vertices.obj = File(paste(unique(edge.prop$Comparison),'vertices','tsv',sep = '.'), 
                    name = paste(unique(edge.prop$Comparison),'Vertices'), 
                    parentId = fullNet.fold$properties$id)
    vertices.obj = synStore(vertices.obj, used = as.character(ALL_USED_IDs), executed = ThisFile, activityName = ActivityName)
    
    return(c(edge.obj, vertices.obj))
  }, 
  counts, .parallel = F, .progress = 'text')
```

Call ranking script seperately (see calculateVertexRanks.R, because of parallel implementation)

#### Retrive rank list and create subnetwork with top 50 nodes
```{r rankList}
rank.id = 'syn6039760'
ALL_USED_IDs = c(ALL_USED_IDs, rank = rank.id)
rankList = downloadFile(rank.id)

# Creat a folder
smallNet.fold = Folder(name = 'Filtered Networks - Top 100 Nodes (with annotations)', parentId = CODE$properties$id)
smallNet.fold = synStore(smallNet.fold)

all.objs = all.interactions %>%
  dlply(.(Comparison), 
        function(edge.prop, counts){
    diffComp = unique(edge.prop$Comparison)
    rk = filter(rankList,
                Comparison %in% diffComp) %>%
      top_n(50, rank)
    
    # Create a graph from edge list
    g = igraph::graph_from_edgelist(
      dplyr::select(edge.prop, feature, target) %>% as.matrix,
      directed = T)
    igraph::E(g)$weight = abs(edge.prop$coexpression)
    
    # Get all vertices that connect the important vertices
    vertices = intersect(V(g)$name, rk$feature)
    vertices = c(vertices,
                 sapply(vertices, function(x){
                   SP = shortest_paths(g, x, vertices)$vpath %>% unlist
                   names(SP)
                   }) %>% unlist %>% unique)
    
    edge.prop = edge.prop %>%
      filter(feature %in% vertices & target %in% vertices)
    
    # Get pathwyas that maps atleast to 3 entities
    p = pathways %>%
      filter(target %in% vertices) 
    pn = p %>%
      group_by(feature) %>%
      summarise(count = n()) %>%
      filter(count >= max(round(0.3*length(vertices)), 3))
    p = filter(p, feature %in% pn$feature)
    
    edge.prop  = rbindlist(list(edge.prop, p), use.names=T, fill = T)

    vertex.prop = filter(counts,
                          feature %in% vertices) %>%
      left_join(rankList %>%
                  filter(Comparison %in% diffComp) %>%
                  dplyr::select(feature, rank))
    
    # Write filtered interactions to synapse
    write.table(edge.prop, file = paste(diffComp,'edges','tsv',sep = '.'), sep = '\t', row.names=F, quote=F)
    edge.obj = File(paste(diffComp,'edges','tsv',sep = '.'), 
                    name = paste(diffComp,'Edges'), 
                    parentId = smallNet.fold$properties$id)
    edge.obj = synStore(edge.obj, used = as.character(ALL_USED_IDs), executed = ThisFile, activityName = ActivityName)
    
    # Write filtered nodes to synapse
    write.table(vertex.prop, file = paste(diffComp,'vertices','tsv',sep = '.'), sep = '\t', row.names=F, quote=F)
    vertices.obj = File(paste(diffComp,'vertices','tsv',sep = '.'), 
                        name = paste(diffComp,'Vertices'), 
                        parentId = smallNet.fold$properties$id)
    vertices.obj = synStore(vertices.obj, used = as.character(ALL_USED_IDs), executed = ThisFile, activityName = ActivityName)
    
    return(c(edge.obj, vertices.obj))
  }, 
  counts, .parallel = F, .progress = 'text')
```

### Source Code
[Source R Markdown](`r ThisFile`)