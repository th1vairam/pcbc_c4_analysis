---
title: "Network fusion analysis of mRNA, miRNA, and methylation data (filtered, normalised and unadjusted)"
author: "Thanneer Perumal"
date: "`r date()`"
output: html_document
---
```{r libs, echo=FALSE, warning=FALSE, message=FALSE, include=FALSE}
## It is assumed your working directory is where this file is

# Clear R console screen output
cat("\014")  
dev.off()

# Load required libraries
library('synapseClient')
library('data.table')
library('dplyr')
library('knitr')
library('stringr')
library('SNFtool')
library('WGCNA')
library('igraph')
library('cluster')
library('knit2synapse')
library('RColorBrewer')

## Needs the dev branch
library(rGithubClient)

## Requires ggdendro
devtools::source_url("https://raw.githubusercontent.com/chr1swallace/random-functions/master/R/ggplot-heatmap.R")

synapseLogin()

# knitToFolderEntity(file = "./NetFuse_normUnadj_All.Rmd", parentId = 'syn4821700', entityName = 'Network Fusion Analysis Normalised Unadjusted All')

# source utility files from ../R/lib folder
file.sources = list.files('../R/lib',pattern="*.R")
file.sources = sapply(file.sources,function(x){return(paste('../R/lib',x,sep='/'))})
tmp = sapply(file.sources,source,.GlobalEnv)

options(xtable.type="html")

knitr::opts_chunk$set(
  echo=FALSE,
  warning=FALSE,
  message=FALSE,
  error = FALSE,
  tidy = FALSE,
  cache = FALSE)
```

### Download data
```{r setup, include=FALSE}
# Input Parameters
COUNT_IDs = c(MRNA = 'syn4882076', MIRNA = 'syn4882080', METHYL = 'syn4882082')
METADATA_IDs = c(MRNA = 'syn4882084', MIRNA = 'syn4882086', METHYL = 'syn4882088')

parentId = 'syn4821700'

# Specify factor and continuous covarites pool (adjusted covariates will only be the subset of these covariates)
FactorCovariates = c('Diffname_short', 'run', 'lane', 'Cell_Line_Type', 'Cell_Line_of_Origin', 'Tissue_of_Origin', 'Reprogramming_Gene_Combination', 'Culture_Conditions', 'Donor_Life_Stage', 'Race', 'Ethnicity' , 'Gender', 'Disease', 'Originating_Lab', 'Donor_ID', 'Cell_Type_of_Origin_Level2', 'Reprogramming_Vector_Type')
ContCovariates = c('PassageAtThaw', 'PassageAtHarvest')
```

Obtain unadjusted but normalised and filtered log CPM counts for mRNA and miRNA and beta matrix for methylation from synapse.
```{r getdata, cache=TRUE, include=FALSE}
# Get metadata
METADATA = lapply(METADATA_IDs, function(id){
  OBJ = synGet(as.character(id))
  METADATA = fread(OBJ@filePath, data.table=F, header=T)
  row.names(METADATA) = METADATA[,1]
  METADATA = METADATA[,-(1)]
  
  METADATA = METADATA[METADATA$Diffname_short=='EB',]
  return(METADATA)
  })

# Get count matrix
COUNTS = mapply(function(id, METADATA){  
  OBJ = synGet(as.character(id))
  COUNT = fread(OBJ@filePath, data.table=F, header=T)
  row.names(COUNT) = COUNT[,1]
  COUNT = as.matrix(COUNT[,-(1)])
  COUNT = COUNT[,rownames(METADATA)]
  return(list(COUNT))
  }, COUNT_IDs, METADATA)
```

Total number of samples that have all three assays performed are

After summary (replicates are taken as average)
    * mRNA: `r dim(COUNTS$MRNA)[2]`, miRNA: `r dim(COUNTS$MIRNA)[2]`, methylation: `r dim(COUNTS$METHYL)[2]`

### Similarity Network Fusion 
Fusion using eucledian distance 
```{r snf.eucl, include =FALSE}
# Standard normalisation
NORM.COUNTS = lapply(COUNTS, standardNormalization)

# Calculate distance between samples (biweight correlation is used)
DIST = lapply(NORM.COUNTS, function(x){
  D = dist2(t(x),t(x))
  rownames(D) = colnames(x)
  colnames(D) = colnames(x)
  return(D)
  })

# Calculate average degree from individual data
K = mean(sapply(DIST, function(x){
  g = graph.adjacency(x/max(x), mode="undirected", weighted = TRUE)
  k = mean(graph.strength(g),na.rm=T)
  return(k)
  }))

# Get affinity matrix for combining with SNF
W = lapply(DIST, function(x, K, alpha){
  A = affinityMatrix(x, K, alpha)
  rownames(A) = rownames(x)
  colnames(A) = colnames(A)
  return(A)
  }, K, 0.5); # where alpha = 0.5 is the hyperparameter

# Similarity Network Fusion
M = SNF(W, K, t = 20); # where t is the number of iteration 10-20
rownames(M) = colnames(COUNTS$MRNA)
colnames(M) = colnames(COUNTS$MRNA)
```

Cluster of SNF matrix (based on ward distance)

```{r plot.clusters, cache=FALSE, fig.width=10, fig.height=10}
# Plot clustergram of SNF matrix
M1 = M;
diag(M1) = 0;
p <- ggheatmap(M1, brewer.pal(9, 'Reds'))
ggheatmap.show(p, col.width=0.3, row.width=0.15)
```

PAM clustering

```{r pam.cluster}
# Find cluster of samples using spectral clustering
C = 5   				# number of clusters
group = pam(M1, C); 	# the final subtypes information 

kable(table(group$clustering, METADATA$MRNA$Diffname_short), row.names=T)
```

Hierarchichal clustering

```{r hcluster, fig.height=10, fig.width=15, fig.keep='last', cache=FALSE}
clust = hclust(dist(M))
tree = cutreeStatic(clust, cutHeight = 0.785, minSize=3)

# sizeGrWindow(10,8);
p = plotDendroAndColors(clust, 
                        labels2colors(cbind(tree, METADATA$MRNA)),
                        groupLabels = c('Cluster',colnames(METADATA$MRNA)))
```

### Eigen sample calculations
```{r eigen.sample}
calculateModuleEigenSample <- function(x, name, tree){
  ME = moduleEigengenes(x, tree)$eigengenes
  
  dissimME = (1-t(cor(ME, method="p")))/2
  hclustdatME = hclust(as.dist(dissimME), method="average")
  
  # Plot the eigengene dendrogram
  writeLines(paste('Based on',name,'assay'))
  par(mfrow=c(1,1))
  print(plot(hclustdatME, main="Clustering tree based of the module eigensamples"))
  
  # Plot pairs of ME to merge modules
#   print(plotMEpairs(ME))
  
  kME = cor(x, ME)
  return(list(kME))
}
kME = mapply(calculateModuleEigenSample, COUNTS, names(COUNTS), MoreArgs = list(tree))
kME.all = (kME$MRNA + kME$MIRNA + kME$METHYL)/3

MC = intramodularConnectivity(M, tree)
```

Plot of module connectivity (defined as node degree with module members) vs module membership (defined as correlation with module eigen gene) 

```{r mod.plots, fig.height=20, fig.width=20, cache=FALSE}
plotkWvskME <- function(i, j, tree, kME.all, MC, METADATA){
  NUID = rownames(METADATA)
  tmp = data.frame(kWithin = MC$kWithin[tree==i], cor.with.kME = kME.all[tree==i,j])
  tmp = cbind(tmp, METADATA[tree==i,],NUID = NUID[tree==i])
  
  p <- ggplot(tmp, aes(x = kWithin, y = cor.with.kME)) 
  p <- p + geom_point(aes(color=Gender, shape = Cell_Line_Type, size=Diffname_short)) 
#   p <- p + geom_text(aes(label=NUID, size=4, hjust=-0.1))
  p <- p + scale_size_manual(values = 2*(1:length(unique(tmp$Diffname_short))))
  p <- p + theme(legend.position="top") + ggtitle(paste('Module',i,'and Eigen vector',j));
  return(p)
}

p <- list()
for (i in 1:max(tree)){
    for (j in 1:dim(kME.all)[2]){
      tmp = plotkWvskME(i, j, tree, kME.all, MC, METADATA$MRNA)
      p <- c(p, list(tmp))
      }
    }
multiplot(plotlist = p, cols = max(tree))
```

# Store in synapse
```{r synapsestore, echo=FALSE, include=FALSE, eval=TRUE}
ActivityName <- 'Network Fusion Analysis'
  
thisFileName <- 'NetFuse_normUnadj_All.Rmd'
  
# Github link
thisRepo <- getRepo(repository = "th1vairam/pcbc_c4_analysis", 
                    ref="branch", 
                    refName='netfuse')

thisFile <- getPermlink(repository = thisRepo,
                        repositoryPath=paste0('code/Rmd/', thisFileName))
    
# Populate wiki with results
CODE <- Folder(name = 'Network Fusion Analysis Normalised Unadjusted All',parentId = parentId)
CODE <- synStore(CODE)
```